; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=ve-unknown-unknown -mattr=+packed | FileCheck %s


;;; PACKED ;;;

define fastcc <512 x i1> @vec_select_v512i1(<512 x i1> %m, <512 x i1> %t, <512 x i1> %f) {
; CHECK-LABEL: vec_select_v512i1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andm %vm1, %vm2, %vm4
; CHECK-NEXT:    xorm %vm2, %vm2, %vm0
; CHECK-NEXT:    andm %vm2, %vm2, %vm6
; CHECK-NEXT:    orm %vm8, %vm2, %vm1
; CHECK-NEXT:    andm %vm1, %vm3, %vm5
; CHECK-NEXT:    xorm %vm2, %vm3, %vm0
; CHECK-NEXT:    andm %vm2, %vm2, %vm7
; CHECK-NEXT:    orm %vm9, %vm2, %vm1
; CHECK-NEXT:    andm %vm2, %vm0, %vm8
; CHECK-NEXT:    andm %vm3, %vm0, %vm9
; CHECK-NEXT:    b.l.t (, %s10)
  %r = select <512 x i1> %m, <512 x i1> %t, <512 x i1> %f
  ret <512 x i1> %r
}

define fastcc <512 x float> @vec_select_v512f32(<512 x i1> %m, <512 x float> %t, <512 x float> %f) {
; CHECK-LABEL: vec_select_v512f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $vm2 killed $vm2 killed $vmp1 def $vmp1
; CHECK-NEXT:    lea %s0, 256
; CHECK-NEXT:    # kill: def $vm3 killed $vm3 killed $vmp1 def $vmp1
; CHECK-NEXT:    lvl %s0
; CHECK-NEXT:    vmrg.w %v1, %v1, %v0, %vm2
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    b.l.t (, %s10)
  %r = select <512 x i1> %m, <512 x float> %t, <512 x float> %f
  ret <512 x float> %r
}

define fastcc <512 x i1> @vp_select_v512i1(<512 x i1> %m, <512 x i1> %t, <512 x i1> %f, i32 %pivot, i32 %avl) {
; CHECK-LABEL: vp_select_v512i1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andm %vm1, %vm2, %vm4
; CHECK-NEXT:    xorm %vm2, %vm2, %vm0
; CHECK-NEXT:    andm %vm2, %vm2, %vm6
; CHECK-NEXT:    orm %vm8, %vm1, %vm2
; CHECK-NEXT:    andm %vm1, %vm3, %vm5
; CHECK-NEXT:    xorm %vm2, %vm3, %vm0
; CHECK-NEXT:    andm %vm2, %vm2, %vm7
; CHECK-NEXT:    orm %vm9, %vm1, %vm2
; CHECK-NEXT:    andm %vm2, %vm0, %vm8
; CHECK-NEXT:    andm %vm3, %vm0, %vm9
; CHECK-NEXT:    b.l.t (, %s10)
  %r = call <512 x i1> @llvm.vp.select.v512i1(<512 x i1> %t, <512 x i1> %f, <512 x i1> %m, i32 %pivot, i32 %avl)
  ret <512 x i1> %r
}

define fastcc <512 x float> @vp_select_v512f32(<512 x i1> %m, <512 x float> %t, <512 x float> %f, i32 %pivot, i32 %avl) {
; CHECK-LABEL: vp_select_v512f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    # kill: def $vm2 killed $vm2 killed $vmp1 def $vmp1
; CHECK-NEXT:    adds.w.sx %s0, 1, %s0
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    srl %s0, %s0, 1
; CHECK-NEXT:    # kill: def $vm3 killed $vm3 killed $vmp1 def $vmp1
; CHECK-NEXT:    lvl %s0
; CHECK-NEXT:    vmrg.w %v1, %v1, %v0, %vm2
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    b.l.t (, %s10)
  %r = call <512 x float> @llvm.vp.select.v512f32(<512 x float> %t, <512 x float> %f, <512 x i1> %m, i32 %pivot, i32 %avl)
  ret <512 x float> %r
}

declare <512 x float> @llvm.vp.select.v512f32(<512 x float>, <512 x float> passthru, <512 x i1> mask, i32, i32 vlen)
declare <512 x i1> @llvm.vp.select.v512i1(<512 x i1>, <512 x i1> passthru, <512 x i1> mask, i32, i32 vlen)



;;; REGULAR ;;;

define fastcc <256 x i1> @vec_select_v256i1(<256 x i1> %m, <256 x i1> %t, <256 x i1> %f) {
; CHECK-LABEL: vec_select_v256i1:
; CHECK:       # %bb.0:
; CHECK-NEXT:    andm %vm2, %vm1, %vm2
; CHECK-NEXT:    xorm %vm1, %vm1, %vm0
; CHECK-NEXT:    andm %vm1, %vm1, %vm3
; CHECK-NEXT:    orm %vm1, %vm1, %vm2
; CHECK-NEXT:    b.l.t (, %s10)
  %r = select <256 x i1> %m, <256 x i1> %t, <256 x i1> %f
  ret <256 x i1> %r
}

define fastcc <256 x float> @vec_select_v256f32(<256 x i1> %m, <256 x float> %t, <256 x float> %f) {
; CHECK-LABEL: vec_select_v256f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    lea %s0, 256
; CHECK-NEXT:    lvl %s0
; CHECK-NEXT:    vmrg %v1, %v1, %v0, %vm1
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    b.l.t (, %s10)
  %r = select <256 x i1> %m, <256 x float> %t, <256 x float> %f
  ret <256 x float> %r
}

define fastcc <256 x float> @vp_select_v256f32(<256 x i1> %m, <256 x float> %t, <256 x float> %f, i32 %pivot, i32 %avl) {
; CHECK-LABEL: vp_select_v256f32:
; CHECK:       # %bb.0:
; CHECK-NEXT:    and %s0, %s0, (32)0
; CHECK-NEXT:    lvl %s0
; CHECK-NEXT:    vmrg %v1, %v1, %v0, %vm1
; CHECK-NEXT:    lea %s16, 256
; CHECK-NEXT:    lvl %s16
; CHECK-NEXT:    vor %v0, (0)1, %v1
; CHECK-NEXT:    b.l.t (, %s10)
  %r = call <256 x float> @llvm.vp.select.v256f32(<256 x float> %t, <256 x float> %f, <256 x i1> %m, i32 %pivot, i32 %avl)
  ret <256 x float> %r
}

declare <256 x float> @llvm.vp.select.v256f32(<256 x float>, <256 x float> passthru, <256 x i1> mask, i32, i32 vlen)
declare <256 x i1> @llvm.vp.select.v256i1(<256 x i1>, <256 x i1> passthru, <256 x i1> mask, i32, i32 vlen)
